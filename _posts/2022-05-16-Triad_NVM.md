---
layout: post
title: "Triad-NVM:Persistency for Integrity-Protected and Encrypted Non-Volatile Memories"
author: Jianfeng Wu
tags:
 - ISCA
 - 2019
 - NVM
 - Security
---
# [Triad-NVM:Persistency for Integrity-Protected and Encrypted Non-Volatile Memories](https://dl.acm.org/doi/pdf/10.1145/3307650.3322250)

## Introduction

NVMM相比DRAM提供了高容量、非易失性等特性，自从发布之日起就引人注目。由于NVMM的非易失性，它作为内存使用时会存在数据剩磁的安全问题，因此Optane DCPMM附带了硬件内存端加密作为一道防线。但是仅靠硬件内存端加密无法为应用程序提供安全的执行环境，为了实现更全面的保护，处理器端内存安全是必要的。

作者另外发现持久性和安全性虽然以往是正交的，但在NVMM环境中应该放在一起进行研究，以保证系统能够安全地恢复，并在崩溃重启期间保证其数据完整性和机密性。在以往的DRAM环境中，安全元数据默认会在系统启动时重新初始化，天然支持内存安全且不保证数据完整性，而在NVMM环境中则恰好相反。

基于上述原因，作者认为将NVMM作为内存使用需要考虑以下三个方面：维护安全保障、数据可恢复性、快速持久化及恢复。

## Background

由于非易失性，NVMM容易受到被动机密性破坏（如数据剩余攻击）以及通过数据篡改导致的主动完整性破坏。非易失性为攻击者提供了充足的时间执行攻击，因此NVMM必须采用内存加密和完整性验证。加密可以在内存端或处理器端执行。内存端加密针对依赖内存作为信任根的内存产品，但是这种形式下数据仍以明文形式在系统总线上进行通信，使其面临机密性泄漏的风险。处理器端加密以处理器芯片为安全边界，消除了上述问题，但需要对处理器进行修改。数据在离开处理器芯片之前被加密，从NVMM获取时被解密并验证其完整性。

### 内存加密

在计数器模式加密中，加密算法（例如 AES）以初始化向量 (IV) 作为其输入以生成一次性填充 (OTP)，如图所示。稍后，当密文数据块到达处理器芯片时，执行与OTP的低成本按位异或以获得明文。通过这样做，解密延迟与内存访问延迟重叠。除了其性能优势之外，计数器模式内存加密还可以防御各种攻击。计数器模式加密可以安全地抵御基于字典的攻击、已知明文攻击和总线窥探攻击。

![](/images/2022-05-16-Triad_NVM/split_counter_mode_encryption.png)

有几种可能的计数器格式，包括单片（在SGX中使用）和拆分格式。在拆分计数器方案中，加密计数器被组织为主要计数器（在同一页面的缓存行之间共享）和特定于每个缓存行的次要计数器。这种组织允许将64个缓存块的计数器打包到一个64B块中；64个7位次要计数器和64位主要计数器。当主计数器的一个从计数器溢出时，主计数器会增加，其中所有相应的次计数器将被重置，整个页面将使用新的主计数器重新加密。主计数器足够大（例如64位），不会在系统生命周期内溢出。拆分计数器方案比单片计数器方案的空间效率高得多，并且实现了更高的计数器命中率，因此它的性能明显优于单片计数器方案。因此本研究基于拆分计数器方案设计。

### 完整性验证

计数器模式加密的基本安全保证要求计数器值不能重复，以防止被破解。为避免计数器重放攻击，计数器必须使用Bonsai Merkle Tree(BMT)防止篡改。使用BMT，数据只需要通过MAC保护。如图所示，每个与一组数据块相关联的加密计数器块用于计算哈希值(MAC)，该哈希值将与来自其他计数器组的其他哈希值一起使用以创建更低级别的哈希值。最后生成的MAC值称为Root，始终保存在处理器中。每次从不安全区域（例如内存模块）中取出计数器时，都会通过计算上哈希值来验证它，并查看结果是否与处理器中保存的Root匹配。此外，当处理器写入内存块并更新相应的计数器时，必须更新BMT父节点以反映最近的更改。

![](/images/2022-05-16-Triad_NVM/merkle_tree.png)

## Motivation

图中描述了使用严格的持久安全性时的相对系统吞吐量。如图所示，大多数工作负载由于额外写入操作的影响而导致性能严重下降（最多达9.4倍），以确保安全元数据的持久性。为了解决这个问题，本文中定义了安全持久系统的要求，并研究了不同方案对系统性能、恢复时间和弹性的影响。该论文是第一个**考虑安全持久内存上的所有安全元数据**的论文。

![](/images/2022-05-16-Triad_NVM/persist_security_metadate_overhead.png)

## Design

### 持久和非持久区域
   
对于持久区域和非持久区域分别使用两个BMT来保障完整性。

### 根据区域持久性区别对待加密计数器

可以放宽非持久性数据的加密计数器，但是非持久性区域具有不同于易失性内存的漏洞（因为该区域实际上仍是持久性的），因此设计了两种方案：①分别使用两种密钥——持久性密钥和易失性密钥，用于持久性区域和非持久性区域，重启时更换易失性密钥以避免计数器重用；②使用单个密钥，但向加密IV添加会话计数器以区分，持久数据使用session 0，非持久数据使用session n，n初始为1且每次重启时递增。这减少了管理多个密钥的复杂性，而且允许为下一个会话预先计算BMT根，以实现BMT的快速恢复。当前会话计数器值和BMT根一起永久保存在芯片上。本文使用第二种方案。

### 放宽Merkle Tree持久性

如果内存发生错误，某个加密计数器损坏，那么经过层层计算会发现和Merkle Tree根不匹配，因此没有任何内存是可以通过完整性验证的。即使树根可以保存64B而不是8B，但不可纠正的计数器错误仍会导致八分之一的内存丢失/无法验证，这对于预计可包含TB级别数据量的NVM是不可接受的。此外，由于重建Merkle树需要遍历所有加密计数器，因此仅保证加密的持久性将需要很长的恢复时间。

因此本文提出保留Merkle树的前N个级别在处理器内的NVM寄存器上，以保持恢复时间可控并实现对内存损坏位置的高分辨识别。

### 非持久区域崩溃恢复

为了避免重建非持久区域的计数器和Merkle树的巨大开销，本文提出一种延迟的恢复方法，即不用零初始化所有节点，而是用零初始化第1层的中间节点（计数器块的父结点），并依次构造所有上层节点。稍后对计数器值的任何更新会将计数器值清零并相应地更新其父节点。

### 总体设计

如图所示，展示了Triad-NVM设计的写流程。利用了写挂起队列（WPQ）以及片上持久寄存器技术。

![](/images/2022-05-16-Triad_NVM/overview_of_write_on_Triad-NVM.png)

## Evaluation

与严格持久化相比，Triad-NVM将吞吐量提高了大约2倍，为8TB NVMM系统实现了不到4s的恢复时间，详见原文。

## Conclusion

本篇论文的独特性在于第一个考虑了在具有内存加密和完整性验证的系统中全面提供持久性，并定义了安全恢复具有完整性保护和内存加密的系统的要求（安全持久性）。作者还发现NVMM中的持久和非持久性区域需要对安全元数据进行不同的处理。因为本文的系统是设计在一整块NVMM上而不是NVMM与DRAM的混合内存，只是其中NVMM被划分为了持久性区域和非持久性区域，因此其非持久性区域不像DRAM在重启后自行清零，而是需要设计方案来用零初始化。这部分特性的区别使得作者有机会对其进行优化设计。对于安全元数据的全面需求，本文做出的设计是将所有要求全部满足并解决存在的问题。

[返回博客列表](https://haslab.org/blog/)